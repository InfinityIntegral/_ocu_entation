#include <SGDMSgmlGeneration.h>
#include <SGLVector.h>
#include <SGXString.h>
#include <SGDMCppClass.h>
#include <SGDMResultsPage.h>
#include <SGXTimer.h>
#include <SGDMDocumentationParsing.h>
#include <SGXFileSystem.h>
#include <SGXFile.h>
#include <SGLSort.h>
#include <SGLLesserThan.h>
#include <SGLUnorderedMap.h>
#include <SGLEqualsTo.h>
#include <SGLHash.h>
#include <SGLPair.h>
#include <SGDMHtmlGeneration.h>

int SGDMSgmlGeneration::currentGenerationSource = 0;
SGLVector<SGDMCppClass*>* SGDMSgmlGeneration::generationSources = nullptr;
SGXString SGDMSgmlGeneration::githubPrefixLink = "";
SGXString SGDMSgmlGeneration::projectName = "";

void SGDMSgmlGeneration::generateSgml(){
    SGDMResultsPage::updateInfo("preparing SGML generation");
    SGDMSgmlGeneration::generationSources = new SGLVector<SGDMCppClass*>();
    for(SGLUnorderedMap<SGXString, SGDMCppClass, SGLEqualsTo<SGXString>, SGLHash<SGXString>>::Iterator i = SGDMCppClass::allClasses.begin(); i != SGDMCppClass::allClasses.end(); i++){
        (*SGDMSgmlGeneration::generationSources).pushBack(&i.value());
    }
    SGDMSgmlGeneration::currentGenerationSource = 0;
    const SGXString classDocsPath = SGXFileSystem::joinFilePaths(SGDMDocumentationParsing::sourcePath + "SGML_source", "cppclass");
    if(SGXFileSystem::folderExists(classDocsPath) == true){SGXFileSystem::permanentDeleteFolder(classDocsPath);}
    SGXFileSystem::createFolder(classDocsPath);
    const SGXString functionListPath = SGXFileSystem::joinFilePaths(SGDMDocumentationParsing::sourcePath + "SGML_source", "funclist");
    if(SGXFileSystem::folderExists(functionListPath) == true){SGXFileSystem::permanentDeleteFolder(functionListPath);}
    SGXFileSystem::createFolder(functionListPath);
    if(SGDMSgmlGeneration::githubPrefixLink == ""){SGDMResultsPage::addWarning("GitHub link to source files not set");}
    SGXTimer::singleCall(0.0f, &SGDMSgmlGeneration::generateForNextClass);
}

SGXString SGDMSgmlGeneration::createLink(const SGXString &linkText, const SGXString &link){
    return (SGXString("@SG_ML_L") + SGXString::intToStringBase16(linkText.length()).fillLeftToLength(3, '0') + SGXString::intToStringBase16(link.length()).fillLeftToLength(3, '0') + linkText + link);
}

bool MemberOrdering::operator()(const SGDMCppMember* a, const SGDMCppMember* b){
    if((*a).functionName.at(0).isEnglishUppercase() == true && (*b).functionName.at(0).isEnglishUppercase() == false){return true;}
    if((*b).functionName.at(0).isEnglishUppercase() == true && (*a).functionName.at(0).isEnglishUppercase() == false){return false;}
    return ((*a).functionName < (*b).functionName);
}

bool MemberPairOrdering::operator()(const SGLPair<const SGDMCppMember*, SGXString>& a, const SGLPair<const SGDMCppMember*, SGXString>& b){
    if((*a.first).functionName == (*b.first).functionName){return (a.second < b.second);}
    return MemberOrdering()(a.first, b.first);
}

void SGDMSgmlGeneration::generateForNextClass(){
    if(SGDMSgmlGeneration::currentGenerationSource == (*SGDMSgmlGeneration::generationSources).length()){
        SGDMResultsPage::updateInfo("done generating SGML");
        delete SGDMSgmlGeneration::generationSources;
        SGDMSgmlGeneration::generationSources = nullptr;
        SGDMSgmlGeneration::currentGenerationSource = 0;
        SGXTimer::singleCall(0.0f, &SGDMHtmlGeneration::generateHtml);
        return;
    }
    SGDMCppClass& currentClass = (*(*SGDMSgmlGeneration::generationSources).at(SGDMSgmlGeneration::currentGenerationSource));
    SGDMSgmlGeneration::currentGenerationSource++;
    SGDMResultsPage::updateInfo(SGXString("generating ") + SGXString::intToString(SGDMSgmlGeneration::currentGenerationSource) + " of " + SGXString::intToString((*SGDMSgmlGeneration::generationSources).length()) + " SGML files");
    
    SGXString fileContents = "";
    fileContents += "@SG_ML_COMMENT This SGML documentation file is automatically generated by _ocu_mentation, the 05524F internal documentation generation app.\n";
    fileContents += SGXString("@SG_ML_PAGENAME ") + currentClass.className + " Documentation\n";
    fileContents += SGXString("@SG_ML_TITLE ") + currentClass.className + "\n";
    fileContents += "@SG_ML_BLANKLINE\n";
    fileContents += SGDMSgmlGeneration::createLink("see header file", SGDMSgmlGeneration::githubPrefixLink + currentClass.headerPath) + "\n";
    if(currentClass.sourcePath == ""){fileContents += "(no source file, everything inside header)\n";}
    else{fileContents += SGDMSgmlGeneration::createLink("see source file", SGDMSgmlGeneration::githubPrefixLink + currentClass.sourcePath) + "\n";}
    fileContents += "@SG_ML_BLANKLINE\n";
    if(currentClass.templateInfo != ""){fileContents += currentClass.templateInfo + " class " + currentClass.className + ";\n";}
    else{fileContents += SGXString("class ") + currentClass.className + ";\n";}
    fileContents += SGXString("part of ") + SGDMSgmlGeneration::projectName + " module " + SGDMSgmlGeneration::createLink(currentClass.moduleName, SGXString("../modules/") + currentClass.moduleName.getLowerLanguageAware()) + "\n";
    fileContents += currentClass.briefDescription + "\n";
    fileContents += SGDMSgmlGeneration::createLink("detailed description", "#sg_detaileddescription") + "\n";
    fileContents += SGDMSgmlGeneration::createLink("list of all including inherited members", SGXString("../funclist/") + currentClass.className.getLowerLanguageAware().replace(SGXChar(':'), SGXChar('_'))) + "\n";
    fileContents += SGDMSgmlGeneration::createLink("implementation details", "#sg_implementationdetails") + "\n";
    fileContents += "@SG_ML_BLANKLINE\n";
    fileContents += SGXString("preprocessor file inclusion directive: #include <") + currentClass.headerPath.substringRight(currentClass.headerPath.length() - currentClass.headerPath.findFirstFromRight(SGXChar('/')) - 1) + ">\n";
    fileContents += "CMake commands:\n";
    fileContents += SGXString("&#9;find_package(") + SGDMSgmlGeneration::createLink(SGDMSgmlGeneration::projectName, "../readme/readme") + " REQUIRED COMPONENTS " + SGDMSgmlGeneration::createLink(currentClass.moduleName, SGXString("../modules/") + currentClass.moduleName.getLowerLanguageAware()) + ")\n";
    fileContents += SGXString("&#9;target_link_libraries(yourCMakeTarget PRIVATE ") + SGDMSgmlGeneration::createLink(SGDMSgmlGeneration::projectName + "::" + currentClass.moduleName, SGXString("../modules/") + currentClass.moduleName.getLowerLanguageAware()) + ")\n";
    if(currentClass.parentClass == ""){fileContents += "parent class: (none)\n";}
    else{fileContents += SGXString("parent class: ") + SGDMSgmlGeneration::createLink(currentClass.parentClass, currentClass.parentClass.getLowerLanguageAware()) + "\n";}
    if(currentClass.childrenClass.length() == 0){fileContents += "children classes: (none)\n";}
    else{
        fileContents += "children classes: ";
        SGLSort<SGXString, SGLLesserThan<SGXString>>::sort(currentClass.childrenClass.pointerToData(0), currentClass.childrenClass.pointerToData(currentClass.childrenClass.length()));
        fileContents += SGDMSgmlGeneration::createLink(currentClass.childrenClass.at(0), currentClass.childrenClass.at(0).getLowerLanguageAware());
        for(int i=1; i<currentClass.childrenClass.length(); i++){
            fileContents += SGXString(", ") + SGDMSgmlGeneration::createLink(currentClass.childrenClass.at(i), currentClass.childrenClass.at(i).getLowerLanguageAware());
        }
        fileContents += "\n";
    }
    fileContents += "@SG_ML_BLANKLINE\n";
    
    SGLVector<const SGDMCppMember*> pureVirtualFunctions;
    SGLVector<const SGDMCppMember*> instanceVariables;
    SGLVector<const SGDMCppMember*> instanceFunctions;
    SGLVector<const SGDMCppMember*> staticVariables;
    SGLVector<const SGDMCppMember*> staticFunctions;
    for(SGLUnorderedMap<SGXString, SGDMCppMember, SGLEqualsTo<SGXString>, SGLHash<SGXString>>::ConstIterator i = currentClass.members.constBegin(); i != currentClass.members.constEnd(); i++){
        if(i.value().isPrivateAPI == true){continue;}
        if(i.value().isPureVirtual == true){
            pureVirtualFunctions.pushBack(&i.value());
            continue;
        }
        if(i.value().isStatic == true){
            if(i.value().isFunction == true){staticFunctions.pushBack(&i.value());}
            else{staticVariables.pushBack(&i.value());}
            continue;
        }
        if(i.value().isFunction == true){instanceFunctions.pushBack(&i.value());}
        else{instanceVariables.pushBack(&i.value());}
    }
    if(pureVirtualFunctions.length() > 0){
        SGLSort<const SGDMCppMember*, MemberOrdering>::sort(pureVirtualFunctions.pointerToData(0), pureVirtualFunctions.pointerToData(pureVirtualFunctions.length()));
        fileContents += "@SG_ML_HEADER_ pure virtual functions\n";
        for(int i=0; i<pureVirtualFunctions.length(); i++){
            fileContents += SGXString("&#9;") + SGDMSgmlGeneration::autoLinkMemberName(pureVirtualFunctions.at(i), "") + "\n";
        }
        fileContents += "@SG_ML_BLANKLINE\n";
    }
    if(instanceVariables.length() > 0){
        SGLSort<const SGDMCppMember*, MemberOrdering>::sort(instanceVariables.pointerToData(0), instanceVariables.pointerToData(instanceVariables.length()));
        fileContents += "@SG_ML_HEADER_ instance member variables\n";
        for(int i=0; i<instanceVariables.length(); i++){
            fileContents += SGXString("&#9;") + SGDMSgmlGeneration::autoLinkMemberName(instanceVariables.at(i), "") + "\n";
        }
        fileContents += "@SG_ML_BLANKLINE\n";
    }
    if(instanceFunctions.length() > 0){
        SGLSort<const SGDMCppMember*, MemberOrdering>::sort(instanceFunctions.pointerToData(0), instanceFunctions.pointerToData(instanceFunctions.length()));
        fileContents += "@SG_ML_HEADER_ instance member functions\n";
        for(int i=0; i<instanceFunctions.length(); i++){
            fileContents += SGXString("&#9;") + SGDMSgmlGeneration::autoLinkMemberName(instanceFunctions.at(i), "") + "\n";
        }
        fileContents += "@SG_ML_BLANKLINE\n";
    }
    if(staticVariables.length() > 0){
        SGLSort<const SGDMCppMember*, MemberOrdering>::sort(staticVariables.pointerToData(0), staticVariables.pointerToData(staticVariables.length()));
        fileContents += "@SG_ML_HEADER_ static member variables\n";
        for(int i=0; i<staticVariables.length(); i++){
            fileContents += SGXString("&#9;") + SGDMSgmlGeneration::autoLinkMemberName(staticVariables.at(i), "") + "\n";
        }
        fileContents += "@SG_ML_BLANKLINE\n";
    }
    if(staticFunctions.length() > 0){
        SGLSort<const SGDMCppMember*, MemberOrdering>::sort(staticFunctions.pointerToData(0), staticFunctions.pointerToData(staticFunctions.length()));
        fileContents += "@SG_ML_HEADER_ static member functions\n";
        for(int i=0; i<staticFunctions.length(); i++){
            fileContents += SGXString("&#9;") + SGDMSgmlGeneration::autoLinkMemberName(staticFunctions.at(i), "") + "\n";
        }
        fileContents += "@SG_ML_BLANKLINE\n";
    }
    
    fileContents += "@SG_ML_HEADER_detaileddescription Detailed Description\n";
    fileContents += currentClass.detailedDescription + "\n";
    fileContents += "@SG_ML_BLANKLINE\n";
    fileContents += "@SG_ML_HEADER_implementationdetails Implementation Details\n";
    fileContents += currentClass.implementationDetails + "\n";
    fileContents += "@SG_ML_BLANKLINE\n";
    
    SGLVector<const SGDMCppMember*> allMembers;
    for(int i=0; i<pureVirtualFunctions.length(); i++){
        allMembers.pushBack(pureVirtualFunctions.at(i));
    }
    for(int i=0; i<instanceVariables.length(); i++){
        allMembers.pushBack(instanceVariables.at(i));
    }
    for(int i=0; i<instanceFunctions.length(); i++){
        allMembers.pushBack(instanceFunctions.at(i));
    }
    for(int i=0; i<staticVariables.length(); i++){
        allMembers.pushBack(staticVariables.at(i));
    }
    for(int i=0; i<staticFunctions.length(); i++){
        allMembers.pushBack(staticFunctions.at(i));
    }
    for(int i=0; i<allMembers.length(); i++){
        const SGDMCppMember& currentMember = (*allMembers.at(i));
        fileContents += SGXString("@SG_ML_HEADER_") + currentMember.normalisedSignature + " " + SGDMSgmlGeneration::autoLinkMemberName(allMembers.at(i), "") + "\n";
        for(int j=0; j<currentMember.description.length(); j++){
            fileContents += currentMember.description.at(j) + "\n";
        }
        for(int j=0; j<currentMember.notes.length(); j++){
            fileContents += SGXString("@SG_ML_NOTE ") + currentMember.notes.at(j) + "\n";
        }
        for(int j=0; j<currentMember.warnings.length(); j++){
            fileContents += SGXString("@SG_ML_WARN ") + currentMember.warnings.at(j) + "\n";
        }
        fileContents += "@SG_ML_BLANKLINE\n";
    }
    
    SGXString targetFolder = SGXFileSystem::joinFilePaths(SGDMDocumentationParsing::sourcePath + "SGML_source", "cppclass");
    SGXFile::writeAllText(SGXFileSystem::joinFilePaths(targetFolder, currentClass.className.getLowerLanguageAware().replace(SGXChar(':'), SGXChar('_')) + ".sgml"), fileContents.replace(SGXChar('<'), SGXChar(0x2039)).replace(SGXChar('>'), SGXChar(0x203A)));
    
    fileContents = "";
    fileContents += "@SG_ML_COMMENT This SGML documentation file is automatically generated by _ocu_mentation, the 05524F internal documentation generation app.\n";
    fileContents += SGXString("@SG_ML_PAGENAME ") + currentClass.className + " Function List\n";
    fileContents += SGXString("@SG_ML_TITLE ") + SGDMSgmlGeneration::createLink(currentClass.className, SGXString("../cppclass/") + currentClass.className.getLowerLanguageAware().replace(SGXChar(':'), SGXChar('_'))) + "\n";
    SGLVector<SGLPair<const SGDMCppMember*, SGXString>> functionList;
    const SGDMCppClass* currentClassInHierarchy = &currentClass;
    while(currentClassInHierarchy != nullptr){
        for(SGLUnorderedMap<SGXString, SGDMCppMember, SGLEqualsTo<SGXString>, SGLHash<SGXString>>::ConstIterator i = (*currentClassInHierarchy).members.constBegin(); i != (*currentClassInHierarchy).members.constEnd(); i++){
            if(i.value().isPrivateAPI == true){continue;}
            if(i.value().functionName.at(0).isEnglishUppercase() == true && (*currentClassInHierarchy).className != currentClass.className){continue;}
            functionList.pushBack(SGLPair<const SGDMCppMember*, SGXString>(&i.value(), (*currentClassInHierarchy).className));
        }
        if((*currentClassInHierarchy).parentClass == ""){currentClassInHierarchy = nullptr;}
        else{currentClassInHierarchy = &SGDMCppClass::allClasses.at((*currentClassInHierarchy).parentClass);}
    }
    SGLSort<SGLPair<const SGDMCppMember*, SGXString>, MemberPairOrdering>::sort(functionList.pointerToData(0), functionList.pointerToData(functionList.length()));
    for(int i=0; i<functionList.length(); i++){
        fileContents += SGXString("&#9;") + SGDMSgmlGeneration::autoLinkMemberName(functionList.at(i).first, functionList.at(i).second) + "\n";
    }
    
    targetFolder = SGXFileSystem::joinFilePaths(SGDMDocumentationParsing::sourcePath + "SGML_source", "funclist");
    SGXFile::writeAllText(SGXFileSystem::joinFilePaths(targetFolder, currentClass.className.getLowerLanguageAware().replace(SGXChar(':'), SGXChar('_')) + ".sgml"), fileContents.replace(SGXChar('<'), SGXChar(0x2039)).replace(SGXChar('>'), SGXChar(0x203A)));
    
    SGXTimer::singleCall(0.0f, &SGDMSgmlGeneration::generateForNextClass);
}

SGXString SGDMSgmlGeneration::autoLinkMemberName(const SGDMCppMember *member, const SGXString &className){
    const SGXString& declaration = (*member).fullDeclaration;
    SGXString linkedName = "";
    SGXString currentIdentifier = "";
    bool nextIsEnum = false;
    for(int i=0; i<declaration.length(); i++){
        if(declaration.at(i).isEnglishAlphanumeric() == true || declaration.at(i) == ':'){
            currentIdentifier += declaration.at(i);
        }
        else{
            if(currentIdentifier == "operator"){
                currentIdentifier = (*member).functionName;
                i += ((*member).functionName.length() - 8);
            }
            if(currentIdentifier == ""){
                linkedName += declaration.at(i);
                continue;
            }
            if(currentIdentifier == (*member).functionName || (nextIsEnum == true && currentIdentifier != "")){
                nextIsEnum = false;
                if(className == ""){linkedName += SGDMSgmlGeneration::createLink(currentIdentifier, SGXString("#") + (*member).normalisedSignature) + declaration.at(i);}
                else{
                    linkedName += SGDMSgmlGeneration::createLink(className, SGXString("../cppclass/") + className.getLowerLanguageAware().replace(SGXChar(':'), SGXChar('_')));
                    linkedName += "::";
                    linkedName += SGDMSgmlGeneration::createLink(currentIdentifier, SGXString("../cppclass/") + className.getLowerLanguageAware().replace(SGXChar(':'), SGXChar('_')) + "#" + (*member).normalisedSignature) + declaration.at(i);
                }
            }
            else if(SGDMCppClass::allClasses.contains(currentIdentifier) == true){linkedName += (SGDMSgmlGeneration::createLink(currentIdentifier, currentIdentifier.getLowerLanguageAware().replace(SGXChar(':'), SGXChar('_'))) + declaration.at(i));}
            else{
                linkedName += (currentIdentifier + declaration.at(i));
                if(currentIdentifier == "enum"){nextIsEnum = true;}
            }
            currentIdentifier = "";
        }
    }
    return linkedName;
}
